#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# @Function
# Find duplicate classes among java lib dirs and class dirs..
#
# @Usage
#   $ show-duplicate-java-classes # find jars from current dir
#   $ show-duplicate-java-classes path/to/lib_dir1 /path/to/lib_dir2
#   $ show-duplicate-java-classes -c path/to/class_dir1 -c /path/to/class_dir2
#
# @online-doc https://github.com/oldratlee/useful-scripts/blob/dev-2.x/docs/java.md#-show-duplicate-java-classes
# @author tg123 (farmer1992 at gmail dot com)
# @author Jerry Lee (oldratlee at gmail dot com)

__author__ = 'tg123'

import re
import sys
from glob import glob
from io import BytesIO
from optparse import OptionParser
from os import walk
from os.path import relpath, isdir
from zipfile import ZipFile, BadZipfile


################################################################################
# utils functions
################################################################################

def print_box_message(msg):
    print()
    print('=' * 80)
    print(msg)
    print('=' * 80)


def list_jar_file_under_lib_dirs(lib_dirs, recursive):
    jar_files = set()
    for lib_dir in lib_dirs:
        if isdir(lib_dir):
            if recursive:
                jar_files |= {
                    dir_path + '/' + filename
                    for dir_path, _, file_names in walk(lib_dir)
                    for filename in file_names if filename.lower().endswith('.jar')
                }
            else:
                jar_files |= {f for f in glob(lib_dir + '/*.jar')}
        else:
            jar_files.add(lib_dir)
    return jar_files


def list_class_under_jar_file(jar_file, recursive):
    """
    :return: map: jar_jar_path('a.jar!b.jar!c.jar') -> classes
    """

    def list_zip_in_zip(jar_paths, zf):
        ret = {}
        classes = {f for f in zf.namelist() if f.lower().endswith('.class')}
        ret[jar_paths] = classes
        if not recursive:
            return ret

        jars_in_jar = {f for f in zf.namelist() if f.lower().endswith('.jar')}
        for jar in jars_in_jar:
            zip_paths = jar_paths + '!' + jar
            try:
                with ZipFile(BytesIO(zf.read(jar))) as f:
                    ret.update(list_zip_in_zip(zip_paths, f))
            except BadZipfile as e:
                print('WARN: %s is bad zip file(%s), ignored!' % (zip_paths, e), file=sys.stderr)

        return ret

    try:
        with ZipFile(jar_file) as zip_file:
            return list_zip_in_zip(jar_file, zip_file)
    except BadZipfile as error:
        print('WARN: %s is bad zip file(%s), ignored!' % (jar_file, error), file=sys.stderr)
        return {}


def list_class_under_class_dir(class_dir):
    return {relpath(dir_path + '/' + filename, class_dir)
            for dir_path, _, file_names in walk(class_dir)
            for filename in file_names if filename.lower().endswith('.class')}


################################################################################
# biz functions
################################################################################

def build_index__class_to_class_paths(jar_files, class_dirs, recursive_jar):
    class_to_class_paths = {}
    class_paths = set()

    # list all classes in jar files
    for jar_file in jar_files:
        for jar_jar_path, classes in list_class_under_jar_file(jar_file, recursive=recursive_jar).items():
            class_paths.add(jar_jar_path)
            for clazz in classes:
                class_to_class_paths.setdefault(clazz, set()).add(jar_jar_path)

    # list all classes in class dirs
    for class_dir in class_dirs:
        class_paths.add(class_dir)
        for class_file in list_class_under_class_dir(class_dir):
            class_to_class_paths.setdefault(class_file, set()).add(class_dir)

    return class_to_class_paths, class_paths


_java9_module_file_pattern = re.compile(r'(^|.*/)module-info\.class$')


def find_duplicate_classes(class_to_class_paths):
    class_paths_to_duplicate_classes = {}

    for clazz, class_paths in class_to_class_paths.items():
        # skip java 9 module-info files
        if _java9_module_file_pattern.match(clazz):
            continue
        if len(class_paths) > 1:
            classes = class_paths_to_duplicate_classes.setdefault(frozenset(class_paths), set())
            classes.add(clazz)

    return class_paths_to_duplicate_classes


def print_duplicate_classes_info(class_paths_to_duplicate_classes):
    # sort kv pairs
    class_paths_to_duplicate_classes = sorted(class_paths_to_duplicate_classes.items(), reverse=True,
                                              key=lambda item: (len(item[0]), len(item[1])))
    # sort key(class_paths) and value(duplicate_classes)
    class_paths_to_duplicate_classes = [(sorted(list(cps)), sorted(list(dcs)))
                                        for cps, dcs in class_paths_to_duplicate_classes]

    print('Found duplicate classes in below %s class paths:' % len(class_paths_to_duplicate_classes))

    idx_str_max_len = len(str(len(class_paths_to_duplicate_classes)))
    for idx, (class_paths, classes) in enumerate(class_paths_to_duplicate_classes, start=1):
        print('[%*d] found %d duplicate classes in %d class paths:\n    %s' % (
            idx_str_max_len, idx,
            len(classes), len(class_paths),
            '\n    '.join(class_paths)
        ))

    print_box_message('Duplicate classes detail info:')
    for idx, (class_paths, classes) in enumerate(class_paths_to_duplicate_classes, start=1):
        print('[%*d] found %d duplicate classes in %d class paths %s :' % (
            idx_str_max_len, idx,
            len(classes), len(class_paths), ' '.join(class_paths)
        ))
        class_idx_str_max_len = len(str(len(classes)))
        for i, c in enumerate(classes, start=1):
            print('    %*d: %s' % (class_idx_str_max_len, i, c))


def print_class_paths_info(class_paths):
    class_paths = sorted(list(class_paths))

    print_box_message('Find in %s class paths:' % len(class_paths))

    idx_str_max_len = len(str(len(class_paths)))
    for idx, class_path in enumerate(class_paths, start=1):
        print('%*d: %s' % (idx_str_max_len, idx, class_path))


def main():
    option_parser = OptionParser(
        usage='%prog [OPTION]...'
              ' [-c class-dir1 [-c class-dir2] ...]'
              ' [lib-dir1|jar-file1 [lib-dir2|jar-file2] ...]'
              '\nFind duplicate classes among java lib dirs and class dirs.'
              '\n\nExamples:'
              '\n  %prog  # find jars from current dir'
              '\n  %prog path/to/lib_dir1 /path/to/lib_dir2'
              '\n  %prog -c path/to/class_dir1 -c /path/to/class_dir2'
    )
    option_parser.add_option('-L', '--recursive-lib', dest='recursive_lib', default=False,
                             action='store_true', help='find jars in the sub-directories of lib dir')
    option_parser.add_option('-J', '--recursive-jar', dest='recursive_jar', default=False,
                             action='store_true', help='find jars in the jar file')
    option_parser.add_option('-c', '--class-dir', dest='class_dirs', default=[],
                             action='append', help='add class dir')
    options, lib_dirs = option_parser.parse_args()
    recursive_lib = options.recursive_lib
    recursive_jar = options.recursive_jar
    if not options.class_dirs and not lib_dirs:
        lib_dirs = ['.']

    class_to_class_paths, class_paths = build_index__class_to_class_paths(
        list_jar_file_under_lib_dirs(lib_dirs, recursive=recursive_lib),
        options.class_dirs, recursive_jar=recursive_jar)

    class_paths_to_duplicate_classes = find_duplicate_classes(class_to_class_paths)

    have_duplicate_classes = bool(class_paths_to_duplicate_classes)
    if have_duplicate_classes:
        print_duplicate_classes_info(class_paths_to_duplicate_classes)
    else:
        print('COOL! No duplicate classes found!')

    print_class_paths_info(class_paths)

    return int(have_duplicate_classes)


if __name__ == '__main__':
    exit(main())
