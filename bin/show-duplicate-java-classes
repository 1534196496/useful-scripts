#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# @Function
# Find duplicate class among java libs.
#
# @Usage
#   $ show-duplicate-java-classes # find jars from current dir
#   $ show-duplicate-java-classes path/to/lib_dir1 /path/to/lib_dir2
#   $ show-duplicate-java-classes -c path/to/class_dir1 -c /path/to/class_dir2
#
# @online-doc https://github.com/oldratlee/useful-scripts/blob/dev-2.x/docs/java.md#-show-duplicate-java-classes
# @author tg123 (farmer1992 at gmail dot com)
# @author Jerry Lee (oldratlee at gmail dot com)

__author__ = 'tg123'

import re
import sys
from glob import glob
from optparse import OptionParser
from os import walk
from os.path import relpath, isdir
from zipfile import ZipFile, BadZipfile


################################################################################
# utils functions
################################################################################

def print_box_message(msg):
    print()
    print('=' * 80)
    print(msg)
    print('=' * 80)


def list_jar_file_under_lib_dirs(lib_dirs):
    jar_files = set()
    for lib_dir in lib_dirs:
        if isdir(lib_dir):
            jar_files |= {f for f in glob(lib_dir + '/*.jar')}
        else:
            jar_files.add(lib_dir)
    return jar_files


def list_class_under_jar_file(jar_file):
    try:
        return {f for f in ZipFile(jar_file).namelist() if f.lower().endswith('.class')}
    except BadZipfile:
        print('WARN: %s is bad zip file, ignored!' % jar_file, file=sys.stderr)
        return set()


def list_class_under_class_dir(class_dir):
    return {relpath(dir_path + '/' + filename, class_dir)
            for dir_path, _, file_names in walk(class_dir)
            for filename in file_names if filename.lower().endswith('.class')}


################################################################################
# biz functions
################################################################################

def build_index__class_to_class_paths(jar_files, class_dirs):
    class_to_class_paths = {}

    # list all classes in jar files
    for jar_file in jar_files:
        for class_file in list_class_under_jar_file(jar_file):
            class_to_class_paths.setdefault(class_file, set()).add(jar_file)

    # list all classes in class dirs
    for class_dir in class_dirs:
        for class_file in list_class_under_class_dir(class_dir):
            class_to_class_paths.setdefault(class_file, set()).add(class_dir)

    return class_to_class_paths, jar_files | set(class_dirs)


_java9_module_file_pattern = re.compile(r'(^|.*/)module-info\.class$')


def find_duplicate_classes(class_to_class_paths):
    class_paths_to_duplicate_classes = {}

    for clazz, class_paths in class_to_class_paths.items():
        # skip java 9 module-info files
        if _java9_module_file_pattern.match(clazz):
            continue
        if len(class_paths) > 1:
            classes = class_paths_to_duplicate_classes.setdefault(frozenset(class_paths), set())
            classes.add(clazz)

    return class_paths_to_duplicate_classes


def print_duplicate_classes_info(class_paths_to_duplicate_classes):
    # sort kv pairs
    class_paths_to_duplicate_classes = sorted(class_paths_to_duplicate_classes.items(), reverse=True,
                                              key=lambda item: (len(item[0]), len(item[1])))
    # sort key(class_paths) and value(duplicate_classes)
    class_paths_to_duplicate_classes = [(sorted(list(cps)), sorted(list(dcs)))
                                        for cps, dcs in class_paths_to_duplicate_classes]

    print('Found duplicate classes in below %s class paths:' % len(class_paths_to_duplicate_classes))

    idx_str_max_len = len(str(len(class_paths_to_duplicate_classes)))
    for idx, (class_paths, classes) in enumerate(class_paths_to_duplicate_classes, start=1):
        print('[%*d] found %d duplicate classes in %d class paths:\n    %s' % (
            idx_str_max_len, idx,
            len(classes), len(class_paths),
            '\n    '.join(class_paths)
        ))

    print_box_message('Duplicate classes detail info:')
    for idx, (class_paths, classes) in enumerate(class_paths_to_duplicate_classes, start=1):
        print('[%*d] found %d duplicate classes in %d class paths %s :' % (
            idx_str_max_len, idx,
            len(classes), len(class_paths), ' '.join(class_paths)
        ))
        class_idx_str_max_len = len(str(len(classes)))
        for i, c in enumerate(classes, start=1):
            print('    %*d: %s' % (class_idx_str_max_len, i, c))


def print_class_paths_info(class_paths):
    class_paths = sorted(list(class_paths))

    print_box_message('Find in %s class paths:' % len(class_paths))

    idx_str_max_len = len(str(len(class_paths)))
    for idx, class_path in enumerate(class_paths, start=1):
        print('%*d: %s' % (idx_str_max_len, idx, class_path))


def main():
    option_parser = OptionParser('usage: %prog '
                                 '[-c class-dir1 [-c class-dir2] ...] '
                                 '[lib-dir1|jar-file1 [lib-dir2|jar-file2] ...]')
    option_parser.add_option('-c', '--class-dir', dest='class_dirs', default=[], action='append', help='add class dir')
    options, lib_dirs = option_parser.parse_args()
    if not options.class_dirs and not lib_dirs:
        lib_dirs = ['.']

    class_to_class_paths, class_paths = build_index__class_to_class_paths(
        list_jar_file_under_lib_dirs(lib_dirs), options.class_dirs)

    class_paths_to_duplicate_classes = find_duplicate_classes(class_to_class_paths)

    have_duplicate_classes = bool(class_paths_to_duplicate_classes)
    if have_duplicate_classes:
        print_duplicate_classes_info(class_paths_to_duplicate_classes)
    else:
        print('COOL! No duplicate classes found!')

    print_class_paths_info(class_paths)

    return int(have_duplicate_classes)


if __name__ == '__main__':
    exit(main())
